var config = require( './config.json' );
// new Ajax('/xxx')  					只传url版本号之后的地址
// 	.config({timeout: 3000})	配置，timeout 超时时间，async 异步 默认true
// 	.router([])								路由参数，数组，只有一个可以传字符串
// 	.data({})									post参数
// 	.path({})									？之后参数
// 	.success(fn)							成功回调函数
// 	.error(fn)								失败回调函数
// 	.timeout(fn)							超时回掉函数
// .get();post();	put();delete();						最后 用 get / post 发送请求

function Ajax( url ) {
	if( typeof url !== 'string' )
		throw new Error( 'Ajax option error!' );

	// 判断是否是完整地址 如果不是则加上
	this.url = !~url.indexOf( 'http' ) ? config.ajax_base + '/v' + config.version + url.replace( /^\/*/,'/' ) : url;
}

// Ajax 配置
Ajax.prototype.config = function( cfg ){
	this.cfg = cfg;
	return this;
}

// Ajax 路径参数
Ajax.prototype.router = function( router ){

	if( !router )
		throw new Error( 'Router参数错误，必须为数组或者字符串' );

	if( router.constructor.name === 'String' )
		router = '/' + router;
	else
		router = '/' + router.join( '/' );

	var aUrl = this.url.split( '?' );
	this.url = aUrl[0].replace( /\/*$/, router );
	aUrl[1] && (this.url = this.url + aUrl[1]);

	this.r = router;
	return this;
}

// Ajax data参数
Ajax.prototype.data = function( data ){
	var sData = [];
	for( var i in data )
		sData.push( i + '=' + data[i] );
	sData =  '&' + sData.join( '&' );

	this.d = sData;
	return this;
}

// Ajax ?后面参数
Ajax.prototype.path = function ( path ){

	var sPath = [];
	for( var i in path )
		sPath.push( i + '=' + path[i] );
	sPath =  sPath.join( '&' );

	if( !~this.url.indexOf( '?' ) )
		this.url = this.url.replace( /\/*$/, '?' + sPath )
	else
		this.url = this.url.replace( /[&\/]*$/, '&' + sPath );

	this.p = sPath;
	return this;
}

// Ajax 成功回掉函数
Ajax.prototype.success = function( fn ) {
	if( !fn || typeof fn  !== 'function' )
		throw new Error( '成功回调函数格式错误!' );

	this.s = fn;
	return this;
}

// Ajax 失败回掉函数
Ajax.prototype.error = function( fn ){
	if( !fn || typeof fn  !== 'function' )
		throw new Error( '错误回调函数格式错误!' );

	this.e = fn;
	return this;
}

// 超时回掉函数
Ajax.prototype.timeout = function( fn ){
	if( !fn || typeof fn  !== 'function' )
		throw new Error( '超时回调函数格式错误!' );

	this.t = fn;
	return this;
}

// get 请求
Ajax.prototype.get = function(){
	this.m = 'GET';
	this.exec();
}

// post 请求
Ajax.prototype.post = function(xx){
	this.m = 'POST';
	this.exec(xx);
}

// put 请求
Ajax.prototype.put = function(){
	this.m = 'PUT';
	this.exec();
}

// delete 请求
Ajax.prototype.delete = function(){
	this.m = 'DELETE';
	this.exec();
}

Ajax.prototype.exec = function(xx){

	this.cfg = this.cfg || {};

	var xhr = new XMLHttpRequest();

	// 超时默认3000毫秒
	xhr.timeout =  this.cfg.timeout || 3000;

	// 异步  默认true
	if(xx == false){
		this.async = false;
	}else{
		this.async = typeof this.cfg.async === 'boolean' ? this.cfg.async : true;
	}
	

	xhr.open( this.m, this.url, this.async );

	if( this.m === 'GET' )
		xhr.send( null );
	else{
		xhr.setRequestHeader( 'Content-Type', 'application/x-www-form-urlencoded' );
		xhr.send( this.d );
	}

	xhr.ontimeout = this.t;

	if( !this.async )
	  callback( xhr, this );
	else
		xhr.onreadystatechange = function(){
			if( xhr.readyState === 4 )
				callback( xhr, this );
		}.bind( this )
}

function callback( xhr, obj ){
	var result = '';
	if( xhr.status == 200 ){
		try{
			result = JSON.parse( xhr.response );
		}catch(e){
			result = xhr.response;
		}
		obj.s( result );
	}else 
		obj.e && obj.e( xhr );
}


module.exports = Ajax;